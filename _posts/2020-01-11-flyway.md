---
layout: post
title: "Flyway"
tags: [flyway, db, sql]
comments: true
---

My speech dump for the lecture about "Flyway" at work.

Again I decided to prepare a report because of a lot of questions came to me
during the usage of another technology. This time it is "Flyway" db migration tool.

Here are the questions:
* What is the data base schema migration?
* Why do we need special tool for doing migrations?
* How "Flyway" manages migrations?
  * What is checksum, why do we need it?
  * What is CRC32?
* "Flyway" functionality overview
* What to do if I want to change migration script?

## What is the data base schema migration?

> Data base schema migration refers to the management of incremental, reversible
> changes and version control to relational database schemas.

It is kind of revision control on database schemas. You define your schema as
the sequence of sql scripts (or another format), when applying each of sql script
upgrades your table schema. So you'll get your database schema and code connected
within version control.

## Why do we need special tool for doing migrations?

Suppose you have to write simple CRUD service. You write code and create database schema.
And after changing logic your schema may also change. As a programmer you have to worry
about schema matching the code version. You can guarantee this match by keeping sql files
which has to be applied sequently to upgrade tables schema to needed version. But, how to know
which sql scripts has to be applied to existing schema table, if you will apply some sql
extra times you may get wrong datas. What if someone has accidentally changed some of this sql
scripts, how you gonna handle such an behaviors?

## How "Flyway" manages migrations?

Flyway creates table called "flyway_schema_history", sample table content:

```
gdetram=# select * from flyway_schema_history ;
 installed_rank | version | description | type |      script      |  checksum   | installed_by |        installed_on        | execution_time | success 
----------------+---------+-------------+------+------------------+-------------+--------------+----------------------------+----------------+---------
              1 | 1       | init        | SQL  | V1__init.sql     |   796952451 | gdetram      | 2019-12-23 23:51:23.343459 |            135 | t
              2 | 2       | data        | SQL  | V2__data.sql     |  -578652452 | gdetram      | 2019-12-23 23:51:23.506668 |            466 | t
              3 | 3       | journal     | SQL  | V3__journal.sql  | -1269172772 | gdetram      | 2019-12-23 23:51:23.987326 |             57 | t
              4 | 4       | telegram    | SQL  | V4__telegram.sql |  1254317203 | gdetram      | 2020-01-12 11:30:25.669901 |             61 | t
              5 | 5       | use real    | SQL  | V5__use_real.sql |  -718922552 | gdetram      | 2020-01-12 11:36:19.69948  |            191 | t
(5 rows)
```

It is like evolution history of tables schema.

All columns are intuitively undestandable except column `checksum`. What it stands for and how is it calculated?

I've googled a little then readed source code of flyway and here is the answer:

Checksum is calculated using `CRC32` algorithm applied to sql file content, and converted to integer value.
What is `CRC32` algorithm?

CRC is the reminder of the division some binary number by some binary polinom.

CRC32 means deleting binary number by number `x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x^ + 1` or `0x0104C11DB7`.
Obviously it is 32 bit integer.

What is the properties of CRC32? The property is that when changing even 1 bit of the binary number you'll get very different checksum.

So, when calculating checksum `flyway` makes sure that migration files has not been accidentally changed.

```scala
import java.util.zip.CRC32

import org.flywaydb.core.internal.util.StringUtils

import scala.io.Source
val V1 = "/home/oybek/garage/test/src/main/resources/db/migration/V1__init.sql"
val V2 = "/home/oybek/garage/test/src/main/resources/db/migration/V2__data.sql"
val V3 = "/home/oybek/garage/test/src/main/resources/db/migration/V3__journal.sql"

def checkSum(paths: String*): Int = {
  val crc = new CRC32
  val sql = paths.map { path =>
    Source
      .fromFile(path)
      .getLines
      .map(line =>
        line.replace("\n", "").mkString
      ).mkString
  }.mkString
  crc.update(sql.getBytes())
  crc.getValue.toInt
}

val c1 = checkSum(V1)
val c2 = checkSum(V2)
val c3 = checkSum(V3)
```

## "Flyway" functionality overview

All you have to do just place `*sql` files in path `resources/db/migration/` in certain format:

```
Prefix  Separator       Suffix
     ↓  ↓               ↓
     V2__Add_new_table.sql
      ↑         ↑
   Version    Description
```

Prefix types:

`V` is for versioned migrations, you can't change after creating like
`R` is for repetable migrations, they are reruned each time checksum is changed, they are used
when you need to create `view/procedures`.
`U` is for undo migrations.

## What to do if I want to change migration script?

You can just write script that does reverse of the last scripts and then remove appropriate rows in `flyway_schema_history` table.

