---
layout: post
title: "Sets and Maps"
tags: [scala, java, collections]
comments: true
---

I used to plan to make a demolition of `Set` and `Map` collections from Scala/Java but had no time.
And now, at last, I'm ready to do it! So let's GO!
![]()
In this article I'm gonna try to analyze what is under the hood of `Set` and `Map` from the
Scala/Java collections library.
![]()
![](https://media.giphy.com/media/3o72F7RrTPW6jymXew/giphy.gif)

Here is the list of the data structures I plan to analyze:

* HashSet (Java)
* HashMap (Java)
* Mutable Set (Scala)
* Mutable Map (Scala)
* Immutable Set (Scala)
* Immutable Map (Scala)

No guide reading, only the code!

# HashSet/HashMap (Java)

The strategy is simple, open IDEA - declare HashSet and go to the code defition.

```java
class Scratch {
    public static void main(String[] args) {
        HashSet<Integer> hashSet = new HashSet<>();
        hashSet.add(1);
    }
}
```

First of all let's look to the constructor:

```java
...
    public HashSet() {
        map = new HashMap<>();
    }
...
```

Ooops! Java's Set is the Map under the hood)
If you look at all other methods - they all just use HashMap's methods.

> The Java's HashSet is just a HashMap where the elements of Set are the keys of HashMap
> and all the keys of HashMap corresponds to the single internally created object

That is why let's focus on HashMap:

```java
class Scratch {
    public static void main(String[] args) {
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        hashMap.put(1, 1);
    }
}
```

Let's also look at the constructor:

```java
/**
 * Constructs an empty <tt>HashMap</tt> with the default initial capacity
 * (16) and the default load factor (0.75).
 */
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
```

**Capacity** - is the size of table (a.k.a. bucket)

**Load factor** - is a measure of how full table has to get before we increase it's capacity.

Ok, now let's look to `put` method:

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

It calls `putVal` method which is pretty complex. So before analyzing `putVal`
let's look to the fields of `HashMap`.

This is a core field of `HashMap`, it represents data structure used to implement `HashMap`.

```java
transient Node<K,V>[] table;
```

Array of objects of type `Node`, `Node` is a simple linked list's node which contains
`hash` `key` `value` and the link to the next `Node`.

And now we are ready to look at `putVal`'s implementation:

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
         boolean evict) {
  Node<K,V>[] tab; Node<K,V> p; int n, i;
  if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;
  if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
  else {
    Node<K,V> e; K k;
    if (p.hash == hash &&
      ((k = p.key) == key || (key != null && key.equals(k))))
      e = p;
    else if (p instanceof TreeNode)
      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
    else {
      for (int binCount = 0; ; ++binCount) {
        if ((e = p.next) == null) {
          p.next = newNode(hash, key, value, null);
          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
          break;
        }
        if (e.hash == hash &&
          ((k = e.key) == key || (key != null && key.equals(k))))
          break;
        p = e;
      }
    }
    if (e != null) { // existing mapping for key
      V oldValue = e.value;
      if (!onlyIfAbsent || oldValue == null)
        e.value = value;
      afterNodeAccess(e);
      return oldValue;
    }
  }
  ++modCount;
  if (++size > threshold)
    resize();
  afterNodeInsertion(evict);
  return null;
}
```
![](https://media.giphy.com/media/tdN4TpyM3dzYA/giphy.gif)

Yeah), it was my first reaction too ;)

But the code is quite understandable.

The first `if` block is for the case when puting first element to HashMap.
We will not go down to look to `resize()` (a.k.a rehash) implementation - article will be too big.
Shortly - it creates new table with double size and "cleverly" copies elements from old table to it.
By "cleverly" I mean method tries to spread elements of trees (growed because of collisions) among
new table.

Second if block:
```java
if ((p = tab[i = (n - 1) & hash]) == null)
  tab[i] = newNode(hash, key, value, null);
```

Is the case no collisions occured and we are adding element.
> We doing 'bitwise and' with hash and size of table. This preserves us from IndexOutOfBound exception.

The else block is the most interesting - here collision handling occurs.

By the code we can figure out that when collision occurs, it just builds linked list.
And when the linked list exceeds some value it transforms to [RB-tree](https://en.wikipedia.org/wiki/Redâ€“black_tree).

But wait wait, we do not override compare method for key's class, how RB-tree is build? (Good question)

If you'll look deeper - you'll see that tree just compares elements bitwise.

Summary: You can imagine HashMap in Java like the row of pots with trees in them. And rehash is
the process when we need more pots and we just replant all tree to new bigger row of pots, possible
breaking tree into smaller ones.

# Scala's mutable HashMap and HashSet

The biggest error was that I used to suppose that Scala's HashSet/HashMap under the hood uses Java's HashSet/HashMap.

![](http://m.quickmeme.com/img/b6/b658f5f86efa249dcfc782049ed315433b1fd26f7d06b09cbe30beb5bec26ef9.jpg)

I will not show code here, just will explain how Scala's mutable HashSet/HashMap works.

## Scala's mutable HashSet

Scala's HashSet is implemented as flat hash table. What does it mean? It means that when element collides with another
it will be placed to the next free cell, search for place is looped, so after `n-1` go to `0`.

Here is the code I wrote to experiment with Scala's mutable HashSet

```scala
object Solution extends App {
  def drawTable(table: Array[AnyRef]): String = {
    table.length + ":[" +
      table
        .map { x =>
          if (x == null) " " else (x.asInstanceOf[Foo].v + 'a').toChar
        }
        .mkString("|") + "]"
  }

  case class Foo(v: Int) {
    override def hashCode(): Int = 0
  }

  val set = new scala.collection.mutable.HashSet[Foo]()

  for (i <- 0 to 25) {
    set.add(Foo(i))

    val tableField = set.getClass.getDeclaredField("table")
    tableField.setAccessible(true)
    val table = tableField.get(set).asInstanceOf[Array[AnyRef]]
    println(drawTable(table))
  }
}
```

I've overrided hashCode method with one which always collides and here is the result:

```
32:[a| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c| | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d| | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e| | | | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f| | | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f|g| | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f|g|h| | | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f|g|h|i| | | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f|g|h|i|j| | | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f|g|h|i|j|k| | | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f|g|h|i|j|k|l| | | | | | | | | | | | | | | | | | | | ]
32:[a|b|c|d|e|f|g|h|i|j|k|l|m| | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
64:[a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ]
```

Using correct hashCode method gives:

```
32:[ | | | | | |a| | | | | | | | | | | | | | | | | | | | | | | | | ]
32:[ | | | | | |a|b| | | | | | | | | | | | | | | | | | | | | | | | ]
32:[ | |c| | | |a|b| | | | | | | | | | | | | | | | | | | | | | | | ]
32:[ | |c| | | |a|b|d| | | | | | | | | | | | | | | | | | | | | | | ]
32:[ | |c| | | |a|b|d| | |e| | | | | | | | | | | | | | | | | | | | ]
32:[ | |c| | | |a|b|d| | |e| | | | | | | | | | | |f| | | | | | | | ]
32:[ | |c| | | |a|b|d| | |e| | | | | | | | | |g| |f| | | | | | | | ]
32:[ | |c| | |h|a|b|d| | |e| | | | | | | | | |g| |f| | | | | | | | ]
32:[ | |c| | |h|a|b|d| | |e| | | | | | | | | |g| |f| | | | | |i| | ]
32:[ | |c| | |h|a|b|d| | |e| | | | | | | | | |g| |f| | |j| | |i| | ]
32:[ | |c|k| |h|a|b|d| | |e| | | | | | | | | |g| |f| | |j| | |i| | ]
32:[ | |c|k| |h|a|b|d| | |e| | | | | | | | | |g| |f| | |j|l| |i| | ]
32:[ | |c|k| |h|a|b|d| | |e| | | | | | | | | |g| |f| | |j|l| |i|m| ]
64:[ | |c| | |h| | |d| | | | | | | | | | | | |g| | | |n|j|l| | | | | | |k| | | |a|b| | | |e| | | | | | | | | | | |f| | | | | |i|m| ]
64:[ | |c| | |h| |o|d| | | | | | | | | | | | |g| | | |n|j|l| | | | | | |k| | | |a|b| | | |e| | | | | | | | | | | |f| | | | | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| | | |n|j|l| | | | | | |k| | | |a|b| | | |e| | | | | | | | | | | |f| | | | | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q| |n|j|l| | | | | | |k| | | |a|b| | | |e| | | | | | | | | | | |f| | | | | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q| |n|j|l| | | | | | |k| | | |a|b| |r| |e| | | | | | | | | | | |f| | | | | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l| | | | | | |k| | | |a|b| |r| |e| | | | | | | | | | | |f| | | | | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l| | | | | | |k| | | |a|b| |r| |e| | | | | | | | | | | |f| | |t| | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l| | | | | | |k| | | |a|b|u|r| |e| | | | | | | | | | | |f| | |t| | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l| | | | | | |k| | | |a|b|u|r| |e|v| | | | | | | | | | |f| | |t| | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l| | | | | | |k| | | |a|b|u|r| |e|v| | | | | | | |w| | |f| | |t| | |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l| | | | | | |k| | | |a|b|u|r| |e|v| | | | | | | |w| | |f| | |t|x| |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l|y| | | | | |k| | | |a|b|u|r| |e|v| | | | | | | |w| | |f| | |t|x| |i|m| ]
64:[ | |c| | |h| |o|d| | |p| | | | | | | | | |g| |q|s|n|j|l|y| | | | | |k| | | |a|b|u|r| |e|v| | | | | | | |w| | |f|z| |t|x| |i|m| ]
```

Try to analyze Scala's HashMap yourself - it is awesome.

# Scala's immutable HashSet and HashMap

And now, at last, the most interesting part of article. Immutable HashSet and HashMap of Scala.

First, I want to mark, that Set is very optimized for little sizes, for example, there are
Set1, Set2, ... Set4 instances which are optimized for certain sizes.

But if you look at Set4's `+` implementation:

```scala
def + (elem: A): Set[A] =
  if (contains(elem)) this
  else new HashSet[A] + elem1 + elem2 + elem3 + elem4 + elem
```

Here it is, bridge where we go to immutable HashSet.

Immutable HashSet is implemented as Hash Array Mapped Trie (HAMT).

It is data structure invented and described by Phil Bagwell.

The idea of data structure is to use hashes of keys as prefixes
to build the prefix tree.

Here is [very good introduction article](https://idea.popcount.org/2012-07-25-introduction-to-hamt/).

